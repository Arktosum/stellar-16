enum CONTROL_SIGNALS {
    ALU_INCREMENT = 1 << 22,
    ALU_SUB     = 1  << 21,
    MEMORY_READ =  1 << 20,
    MEMORY_WRITE = 1 << 19,
    A_READ_DBUS =  1 << 18,
    A_WRITE_DBUS = 1 << 17,
    B_READ_DBUS =  1 << 16,
    B_WRITE_DBUS = 1 << 15,
    IR_READ_DBUS =  1 << 14,
    IR_WRITE_DBUS = 1 << 13,
    PC_READ_ABUS = 1 << 12,
    PC_WRITE_ABUS = 1 << 11,
    PC_INCREMENT = 1 << 10,
    H_READ_DBUS = 1 << 9,
    H_WRITE_DBUS = 1 << 8,
    L_READ_DBUS = 1 << 7,
    L_WRITE_DBUS = 1 << 6,
    HL_READ_ABUS = 1 << 5,
    HL_WRITE_ABUS = 1 << 4,
    ALU_BUFFER_READ_DBUS = 1 << 3,
    ALU_BUFFER_WRITE_DBUS = 1 << 2,
    ALU_FLAG_SET_ENABLE = 1 << 1,
    HALT_CPU = 1 << 0
}

let FETCH_MICROCODE = [
    CONTROL_SIGNALS.PC_WRITE_ABUS| CONTROL_SIGNALS.MEMORY_READ,
    CONTROL_SIGNALS.IR_READ_DBUS | CONTROL_SIGNALS.PC_INCREMENT
]
let NOP_MICROCODE = [
    0
]
let LDA_MICROCODE = [
    CONTROL_SIGNALS.PC_WRITE_ABUS| CONTROL_SIGNALS.MEMORY_READ,
    CONTROL_SIGNALS.L_READ_DBUS | CONTROL_SIGNALS.PC_INCREMENT,
    CONTROL_SIGNALS.PC_WRITE_ABUS| CONTROL_SIGNALS.MEMORY_READ,
    CONTROL_SIGNALS.H_READ_DBUS | CONTROL_SIGNALS.PC_INCREMENT,
    CONTROL_SIGNALS.HL_WRITE_ABUS | CONTROL_SIGNALS.MEMORY_READ,
    CONTROL_SIGNALS.A_READ_DBUS
]
let HLT_MICROCODE = [CONTROL_SIGNALS.HALT_CPU]
let STA_MICROCODE = [
    CONTROL_SIGNALS.PC_WRITE_ABUS| CONTROL_SIGNALS.MEMORY_READ,
    CONTROL_SIGNALS.L_READ_DBUS | CONTROL_SIGNALS.PC_INCREMENT,
    CONTROL_SIGNALS.PC_WRITE_ABUS| CONTROL_SIGNALS.MEMORY_READ,
    CONTROL_SIGNALS.H_READ_DBUS | CONTROL_SIGNALS.PC_INCREMENT,
    CONTROL_SIGNALS.HL_WRITE_ABUS |CONTROL_SIGNALS.A_WRITE_DBUS| CONTROL_SIGNALS.MEMORY_WRITE,
]
let JMP_MICROCODE = [
    CONTROL_SIGNALS.PC_WRITE_ABUS| CONTROL_SIGNALS.MEMORY_READ,
    CONTROL_SIGNALS.L_READ_DBUS | CONTROL_SIGNALS.PC_INCREMENT,
    CONTROL_SIGNALS.PC_WRITE_ABUS| CONTROL_SIGNALS.MEMORY_READ,
    CONTROL_SIGNALS.H_READ_DBUS | CONTROL_SIGNALS.PC_INCREMENT,
    CONTROL_SIGNALS.HL_WRITE_ABUS | CONTROL_SIGNALS.PC_READ_ABUS
]

let JMP_CONDITIONAL_MICROCODE = [
    CONTROL_SIGNALS.PC_INCREMENT,
    CONTROL_SIGNALS.PC_INCREMENT,
]
  // ADD M , A <- A + M
let ADD_M_MICROCODE = [
    CONTROL_SIGNALS.PC_WRITE_ABUS| CONTROL_SIGNALS.MEMORY_READ,
    CONTROL_SIGNALS.L_READ_DBUS | CONTROL_SIGNALS.PC_INCREMENT,
    CONTROL_SIGNALS.PC_WRITE_ABUS| CONTROL_SIGNALS.MEMORY_READ,
    CONTROL_SIGNALS.H_READ_DBUS | CONTROL_SIGNALS.PC_INCREMENT,
    CONTROL_SIGNALS.HL_WRITE_ABUS | CONTROL_SIGNALS.MEMORY_READ | CONTROL_SIGNALS.ALU_BUFFER_READ_DBUS | CONTROL_SIGNALS.ALU_FLAG_SET_ENABLE,
    CONTROL_SIGNALS.ALU_BUFFER_WRITE_DBUS | CONTROL_SIGNALS.A_READ_DBUS
]
// SUB M , A <- A - M
let SUB_M_MICROCODE = [
    CONTROL_SIGNALS.PC_WRITE_ABUS| CONTROL_SIGNALS.MEMORY_READ,
    CONTROL_SIGNALS.L_READ_DBUS | CONTROL_SIGNALS.PC_INCREMENT,
    CONTROL_SIGNALS.PC_WRITE_ABUS| CONTROL_SIGNALS.MEMORY_READ,
    CONTROL_SIGNALS.H_READ_DBUS | CONTROL_SIGNALS.PC_INCREMENT,
    CONTROL_SIGNALS.HL_WRITE_ABUS | CONTROL_SIGNALS.MEMORY_READ | CONTROL_SIGNALS.ALU_BUFFER_READ_DBUS| CONTROL_SIGNALS.ALU_SUB | CONTROL_SIGNALS.ALU_FLAG_SET_ENABLE,
    CONTROL_SIGNALS.ALU_BUFFER_WRITE_DBUS | CONTROL_SIGNALS.A_READ_DBUS
]

// INCREMENT M
let INC_M_MICROCODE = [
    CONTROL_SIGNALS.PC_WRITE_ABUS| CONTROL_SIGNALS.HL_READ_ABUS , CONTROL_SIGNALS.MEMORY_READ,
    CONTROL_SIGNALS.A_READ_DBUS | CONTROL_SIGNALS.ALU_BUFFER_READ_DBUS | CONTROL_SIGNALS.ALU_FLAG_SET_ENABLE | CONTROL_SIGNALS.ALU_INCREMENT,
    CONTROL_SIGNALS.ALU_BUFFER_WRITE_DBUS | CONTROL_SIGNALS.HL_WRITE_ABUS | CONTROL_SIGNALS.MEMORY_WRITE,
]

let DEC_M_MICROCODE = [
    CONTROL_SIGNALS.PC_WRITE_ABUS| CONTROL_SIGNALS.MEMORY_READ,
    CONTROL_SIGNALS.L_READ_DBUS | CONTROL_SIGNALS.PC_INCREMENT,
    CONTROL_SIGNALS.PC_WRITE_ABUS| CONTROL_SIGNALS.MEMORY_READ,
    CONTROL_SIGNALS.H_READ_DBUS | CONTROL_SIGNALS.PC_INCREMENT,
    CONTROL_SIGNALS.HL_WRITE_ABUS | CONTROL_SIGNALS.MEMORY_READ,
    CONTROL_SIGNALS.A_READ_DBUS ,
    CONTROL_SIGNALS.ALU_BUFFER_READ_DBUS | CONTROL_SIGNALS.ALU_FLAG_SET_ENABLE| CONTROL_SIGNALS.ALU_SUB | CONTROL_SIGNALS.ALU_INCREMENT,
    CONTROL_SIGNALS.ALU_BUFFER_WRITE_DBUS | CONTROL_SIGNALS.HL_WRITE_ABUS | CONTROL_SIGNALS.MEMORY_WRITE
]


// MOVAB , B <- A
let MOVAB_MICROCODE = [
    CONTROL_SIGNALS.A_WRITE_DBUS | CONTROL_SIGNALS.B_READ_DBUS
]
// MOVBA , A <- B
let MOVBA_MICROCODE = [
    CONTROL_SIGNALS.B_WRITE_DBUS | CONTROL_SIGNALS.A_READ_DBUS  
]
// A <- A + B
let ADD_B_MICROCODE = [
    CONTROL_SIGNALS.B_WRITE_DBUS | CONTROL_SIGNALS.ALU_BUFFER_READ_DBUS | CONTROL_SIGNALS.ALU_FLAG_SET_ENABLE,
    CONTROL_SIGNALS.ALU_BUFFER_WRITE_DBUS | CONTROL_SIGNALS.A_READ_DBUS
]
// A <- A - B
let SUB_B_MICROCODE = [
    CONTROL_SIGNALS.B_WRITE_DBUS | CONTROL_SIGNALS.ALU_BUFFER_READ_DBUS |  CONTROL_SIGNALS.ALU_SUB | CONTROL_SIGNALS.ALU_FLAG_SET_ENABLE,
    CONTROL_SIGNALS.ALU_BUFFER_WRITE_DBUS | CONTROL_SIGNALS.A_READ_DBUS
]
// ADD IMMEDIATE , A <- A+D
let ADI_A_MICROCODE = [
    CONTROL_SIGNALS.PC_WRITE_ABUS| CONTROL_SIGNALS.MEMORY_READ,
    CONTROL_SIGNALS.ALU_BUFFER_READ_DBUS | CONTROL_SIGNALS.ALU_FLAG_SET_ENABLE | CONTROL_SIGNALS.PC_INCREMENT,
    CONTROL_SIGNALS.ALU_BUFFER_WRITE_DBUS | CONTROL_SIGNALS.A_READ_DBUS
]
let INC_A_MICROCODE = [
    CONTROL_SIGNALS.A_WRITE_DBUS | CONTROL_SIGNALS.ALU_BUFFER_READ_DBUS | CONTROL_SIGNALS.ALU_FLAG_SET_ENABLE | CONTROL_SIGNALS.ALU_INCREMENT,
    CONTROL_SIGNALS.ALU_BUFFER_WRITE_DBUS | CONTROL_SIGNALS.A_READ_DBUS
]

let DEC_A_MICROCODE = [
    CONTROL_SIGNALS.A_WRITE_DBUS | CONTROL_SIGNALS.ALU_BUFFER_READ_DBUS | CONTROL_SIGNALS.ALU_FLAG_SET_ENABLE | CONTROL_SIGNALS.ALU_INCREMENT | CONTROL_SIGNALS.ALU_SUB,
    CONTROL_SIGNALS.ALU_BUFFER_WRITE_DBUS | CONTROL_SIGNALS.A_READ_DBUS
]

// DECREMENT MEMORY , m <- m-1
// INCREMENT MEMORY , m <- m+1
type OPCODEType = {
    code : number
    mnemonic : string
    microcode : number[]
    operandCount:number
}

export default class OPCODES{
    opcodes : OPCODEType[]
    FETCH_MICROCODE : number[]
    constructor(){
        this.opcodes = [
            {code:0x00,mnemonic:"NOP",microcode:NOP_MICROCODE,operandCount:0} ,
            {code:0x01,mnemonic:"LDA",microcode:LDA_MICROCODE,operandCount:2} ,
            {code:0x02,mnemonic:"STA",microcode:STA_MICROCODE,operandCount:2} ,
            {code:0x03,mnemonic:"JMP",microcode:JMP_MICROCODE,operandCount:2} ,
            {code:0x04,mnemonic:"ADD_M",microcode:ADD_M_MICROCODE,operandCount:2} ,
            {code:0x05,mnemonic:"MOVAB",microcode:MOVAB_MICROCODE,operandCount:0} ,
            {code:0x06,mnemonic:"MOVBA",microcode:MOVBA_MICROCODE,operandCount:0} ,
            {code:0x07,mnemonic:"ADD_B",microcode:ADD_B_MICROCODE,operandCount:0} ,
            {code:0x08,mnemonic:"JC",microcode:JMP_CONDITIONAL_MICROCODE,operandCount:2} ,
            {code:0x09,mnemonic:"JNC",microcode:JMP_CONDITIONAL_MICROCODE,operandCount:2} ,
            {code:0x0a,mnemonic:"JZ",microcode:JMP_CONDITIONAL_MICROCODE,operandCount:2} ,
            {code:0x0b,mnemonic:"JNZ",microcode:JMP_CONDITIONAL_MICROCODE,operandCount:2} ,
            {code:0x0c,mnemonic:"SUB_M",microcode:SUB_M_MICROCODE,operandCount:2} ,
            {code:0x0d,mnemonic:"SUB_B",microcode:SUB_B_MICROCODE,operandCount:0} ,
            {code:0x0e,mnemonic:"ADI_A",microcode:ADI_A_MICROCODE,operandCount:1} ,
            {code:0x0f,mnemonic:"INC_A",microcode:INC_A_MICROCODE,operandCount:0} ,
            {code:0x10,mnemonic:"DEC_A",microcode:DEC_A_MICROCODE,operandCount:0} ,
            {code:0x11,mnemonic:"INC_M",microcode:INC_M_MICROCODE,operandCount:2} ,
            {code:0x12,mnemonic:"DEC_M",microcode:DEC_M_MICROCODE,operandCount:2} ,
            {code:0xfe,mnemonic:"HLT",microcode:HLT_MICROCODE,operandCount:0} ,
        ]
        this.FETCH_MICROCODE = FETCH_MICROCODE
    }
    code(requestCode:number):OPCODEType{
        let result = this.opcodes.find((x)=>x.code == requestCode)
        if(result)return result
        throw new Error("Cannot find opcode: " + requestCode)
    }
    mnemonic(requestMnemonic:string):OPCODEType{
        let result = this.opcodes.find((x)=>x.mnemonic == requestMnemonic)
        if(result)return result
        throw new Error("Cannot find opcode: " + requestMnemonic)
    }
}
