## A Compiler for the language stellar (.st)

- Interpreted in cpp
- Weak typing
- Javascript like syntax
- Closures

# Lexical Analysis

The first phase of a compiler is lexical analysis, also known as scanning. This phase reads the source code and breaks it into a stream of tokens, which are the basic units of the programming language. The tokens are then passed on to the next phase for further processing.

# Syntax Analysis

The second phase of a compiler is syntax analysis, also known as parsing. This phase takes the stream of tokens generated by the lexical analysis phase and checks whether they conform to the grammar of the programming language. The output of this phase is usually an Abstract Syntax Tree (AST).

# Semantic Analysis

The third phase of a compiler is semantic analysis. This phase checks whether the code is semantically correct, i.e., whether it conforms to the languageâ€™s type system and other semantic rules.

# Intermediate Code Generation

The fourth phase of a compiler is intermediate code generation. This phase generates an intermediate representation of the source code that can be easily translated into machine code.

# Optimization

The fifth phase of a compiler is optimization. This phase applies various optimization techniques to the intermediate code to improve the performance of the generated machine code.

# Code Generation

The final phase of a compiler is code generation. This phase takes the optimized intermediate code and generates the actual machine code that can be executed by the target hardware.

# Frontend

Source code -> Lexer (Tokens)-> Parser (AST) -> interpreter

1. The interpreter takes in an AST, and evaluates the nodes one by one, walks down the tree,
   till it reaches a primary node like numeric literal and starts to operate and return a
   runtime value.
   A statement returns null RuntimeVal
   An expression returns any non-null runtime value (Number,Boolean,String etc...)
   Make sure Program ASTNode is first evaluated and every statement inside it is recursively evaluated.
   Runtime values are runtime Types

like Number,Null,Boolean etc...

2. Environments -> Basically a tree of runtime variable scopes.
   1: create an environment (parentEnv) required.
   program has a default global environment built in
   2: declareVariable : if variable does not exist, set it ( use a map) or error
   3 : assignVariable/reassign : if variable does not exist, throw error, else assign
   resolving scope - If variable does not exist here, parent might have it. if parent doesn't have it either then error.
   if this environment doesn't have a variable, then obviously it's children will NOT have it.
   4: lookupVar - resolve scope and return variable value, else throw error
   5 : Identifier Nodes can simply use lookupVar to check for values of identifiers!
3. VariableDeclaration is an AST Node type
   {
   kind,constant,identifier,value?
   }
   this VariableDeclaration Node is evaluated appropriately in the Interpreter

4.AssignmentExpression another AST Node type{
kind,assignee - Expression,value - Expression
}
assignments can also be like
x = y = z = 10
so evaluate it like we did addition but right ward

    x = 20 + 4<- Assignment Expression
    assignee = x
    value = 20+4
    Note : asignee is also an expression because, asignee could be an object ( member expression )
    x.age = 21 - 12
    x.age = assignee

# Backend
